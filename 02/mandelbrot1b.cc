#include <cmath>
#include <cstdlib>
#include <iostream>
// TODO: include chrono and use it properly for time measurement
#include <chrono>
#include <vector> // [added for 1b]

#include "complex.h"
#include "lodepng.h"

// TODO: Fix Me!
// int mandelbrot(? ? ? )
//{
//
//}
int mandelbrot(const complex &c, int max_iter, double max_abs)
{
    complex z(0.0, 0.0);
    int n = 0;
    while (n < max_iter && z.abs() <= max_abs)
    {
        z = z * z + c;
        n++;
    }
    return n;
}

int main(int argc, char **argv)
{
    int width = 1024, height = 1024;
    double sx = 2. / width;
    double sy = 2. / height;
    double m = 1.;
    double x0 = -.5, y0 = .0;

    unsigned char *image = NULL;

    image = (unsigned char *)malloc(width * height * 4);

    if (argc > 1)
    {
        m = std::strtod(argv[1], 0);
    }
    if (argc > 2)
    {
        x0 = std::strtod(argv[2], 0);
    }
    if (argc > 3)
    {
        y0 = std::strtod(argv[3], 0);
    }

    // exercise a
    const double max_abs = 2.0; // escape radius constant
    // const int max_iter = 320;   // maximum iteration count

    std::vector<int> max_iter_values = {80, 160, 320, 640}; // added for 1b

    // added for 1b: loop over different iteration counts
    for (int max_iter : max_iter_values)
    {
        auto start = std::chrono::high_resolution_clock::now(); // start timer

        // iterate over image pixels and calculate their value
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                complex c(x0 + sx * (x - width / 2) / m, y0 + sy * (y - height / 2) / m);

                // Test image generated by this template:
                // int color_val = x + y; remove test image
                // TODO: implement correct mandelbrot(???) function
                // int color_val = mandelbrot(???);
                int n = mandelbrot(c, max_iter, max_abs);               // compute iteration count
                int color_val = static_cast<int>(255.0 * n / max_iter); // map to grayscale

                image[4 * width * y + 4 * x + 0] = color_val; // R
                image[4 * width * y + 4 * x + 1] = color_val; // G
                image[4 * width * y + 4 * x + 2] = color_val; // B
                image[4 * width * y + 4 * x + 3] = 255;       // Alpha
            }
        }

        auto end = std::chrono::high_resolution_clock::now(); // end timer
        auto duration =                                       // duration
            std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
        std::cout << "Computation time (max_iter=" << max_iter << "): " // addedfor 1 b
                  << duration << " ms" << std::endl;

        /*Encode the image*/
        // measure time for exercise b: encoding speed
        auto encode_start = std::chrono::high_resolution_clock::now();
        std::string filename = "mandelbrot_" + std::to_string(max_iter) + ".png"; // added for 1 b: change filename according to max_iter
        unsigned error =
            lodepng_encode32_file(filename.c_str(), image, width, height); // changed for 1b: use correct filename
        if (error)
        {
            std::cout << "error " << error << " : " << lodepng_error_text(error)
                      << std::endl;
        }
        auto encode_end = std::chrono::high_resolution_clock::now();
        auto encode_duration =
            std::chrono::duration_cast<std::chrono::milliseconds>(encode_end - encode_start).count();

        std::cout << "Encoding time (max_iter=" << max_iter << "): " // cl output
                  << encode_duration << " ms" << std::endl;

        std::cout << "----------------------------------------" << std::endl; // seperate output
    } // end loop over max_iter values

    /*cleanup*/
    free(image);

    return 0;
}
