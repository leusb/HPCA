#include <cmath>
#include <cstdlib>
#include <iostream>
// TODO: include chrono and use it properly for time measurement
#include <chrono>

#include "complex.h"
#include "lodepng.h"

// TODO: Fix Me!
// int mandelbrot(? ? ? )
//{
//
//}
int mandelbrot(const complex &c, int max_iter, double max_abs)
{
    complex z(0.0, 0.0);
    int n = 0;
    while (n < max_iter && z.abs() <= max_abs)
    {
        z = z * z + c;
        n++;
    }
    return n;
}

int main(int argc, char **argv)
{
    int width = 1024, height = 1024;
    double sx = 2. / width;
    double sy = 2. / height;
    double m = 1.;
    double x0 = -.5, y0 = .0;

    unsigned char *image = NULL;

    image = (unsigned char *)malloc(width * height * 4);

    if (argc > 1)
    {
        m = std::strtod(argv[1], 0);
    }
    if (argc > 2)
    {
        x0 = std::strtod(argv[2], 0);
    }
    if (argc > 3)
    {
        y0 = std::strtod(argv[3], 0);
    }

    // exercise a
    const double max_abs = 2.0; // escape radius constant
    const int max_iter = 320;   // maximum iteration count

    auto start = std::chrono::high_resolution_clock::now(); // start timer

    // iterate over image pixels and calculate their value
    for (int x = 0; x < width; x++)
    {
        for (int y = 0; y < height; y++)
        {
            complex c(x0 + sx * (x - width / 2) / m, y0 + sy * (y - height / 2) / m);

            // Test image generated by this template:
            // int color_val = x + y; remove test image
            // TODO: implement correct mandelbrot(???) function
            // int color_val = mandelbrot(???);
            int n = mandelbrot(c, max_iter, max_abs);               // compute iteration count
            int color_val = static_cast<int>(255.0 * n / max_iter); // map to grayscale // static_cast because we get a double and need to map to int (0-255)
            // if you set R=G=B you get a shade of grey.
            // for small n (quick divergence) we go close to white and vice versa
            image[4 * width * y + 4 * x + 0] = color_val; // R
            image[4 * width * y + 4 * x + 1] = color_val; // G
            image[4 * width * y + 4 * x + 2] = color_val; // B
            image[4 * width * y + 4 * x + 3] = 255;       // Alpha
        }
    }

    auto end = std::chrono::high_resolution_clock::now(); // end timer
    auto duration =                                       // duration
        std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "Computation time: " << duration << " ms" << std::endl;

    /*Encode the image*/
    // measure time for exercise b: encoding speed
    auto encode_start = std::chrono::high_resolution_clock::now();
    unsigned error =
        lodepng_encode32_file("mandelbrot.png", image, width, height);
    if (error)
    {
        std::cout << "error " << error << " : " << lodepng_error_text(error)
                  << std::endl;
    }
    auto encode_end = std::chrono::high_resolution_clock::now();
    auto encode_duration =
        std::chrono::duration_cast<std::chrono::milliseconds>(encode_end - encode_start).count();

    std::cout << "Encoding time: " << encode_duration << " ms" << std::endl;

    /*cleanup*/
    free(image);

    return 0;
}
